"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.FuncCli = exports.TestHttpResponse = exports.TestHttpRequest = exports.TestContext = void 0;
var tslib_1 = require("tslib");
var spawn = require("cross-spawn");
var waitOn = require("wait-on");
var node_fetch_1 = require("node-fetch");
var TestContext = /** @class */ (function () {
    function TestContext() {
        this.invocationId = "";
        this.executionContext = {
            functionName: "",
            invocationId: "",
            functionDirectory: "",
        };
        this.bindings = {};
        this.bindingData = {};
        this.traceContext = {
            attributes: {},
            traceparent: null,
            tracestate: null,
        };
        this.bindingDefinitions = [];
        this.log = Object.assign(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
        }, {
            error: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
            },
            warn: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
            },
            info: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
            },
            verbose: function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
            },
        });
        this.req = new TestHttpRequest();
        this.res = new TestHttpResponse();
    }
    ;
    TestContext.prototype.done = function (err, result) {
        throw new Error("Method not implemented.");
    };
    return TestContext;
}());
exports.TestContext = TestContext;
var TestHttpRequest = /** @class */ (function () {
    function TestHttpRequest() {
        this.method = "GET";
        this.url = "";
        this.headers = {};
        this.query = {};
        this.params = {};
    }
    return TestHttpRequest;
}());
exports.TestHttpRequest = TestHttpRequest;
var TestHttpResponse = /** @class */ (function () {
    function TestHttpResponse() {
    }
    return TestHttpResponse;
}());
exports.TestHttpResponse = TestHttpResponse;
var FuncCli = /** @class */ (function () {
    function FuncCli() {
        this._opts = {};
        this._invocationWaiters = [];
    }
    Object.defineProperty(FuncCli.prototype, "baseUrl", {
        get: function () {
            return "http://localhost:".concat(this._opts.port);
        },
        enumerable: false,
        configurable: true
    });
    FuncCli.prototype.start = function (opts) {
        var _a, _b, _c;
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var port, cwd, env, _d;
            var _this = this;
            return (0, tslib_1.__generator)(this, function (_e) {
                switch (_e.label) {
                    case 0:
                        port = (_a = opts.port) !== null && _a !== void 0 ? _a : 7071;
                        cwd = (_b = opts.cwd) !== null && _b !== void 0 ? _b : process.cwd();
                        env = Object.assign({}, process.env, (_c = opts.env) !== null && _c !== void 0 ? _c : {});
                        this._opts = { port: port, cwd: cwd };
                        _d = this;
                        return [4 /*yield*/, spawnAndWait('func', ['start', '--verbose'], port, { cwd: cwd, env: env })];
                    case 1:
                        _d._funcProcess = _e.sent();
                        this._funcProcess.stdout.on('data', function (data) {
                            var _a;
                            var dataText = (_a = data === null || data === void 0 ? void 0 : data.toString("utf8")) !== null && _a !== void 0 ? _a : "";
                            var lines = dataText.split(/\r?\n/);
                            var _loop_1 = function (line) {
                                var match = /\bExecuted 'Functions\.(.+?)' \((\w+),.+\)/.exec(line);
                                if (match) {
                                    var invocation = {
                                        functionName: match[1],
                                        status: match[2],
                                    };
                                    var completedWaiters_1 = [];
                                    for (var _b = 0, _c = _this._invocationWaiters; _b < _c.length; _b++) {
                                        var waiter = _c[_b];
                                        if (waiter.functionName === invocation.functionName) {
                                            waiter.times--;
                                            waiter.results.push({ status: invocation.status });
                                            if (waiter.times === 0) {
                                                completedWaiters_1.push(waiter);
                                                waiter.resolve(waiter.results);
                                            }
                                        }
                                    }
                                    _this._invocationWaiters = _this._invocationWaiters.filter(function (waiter) { return !completedWaiters_1.includes(waiter); });
                                }
                            };
                            for (var _i = 0, lines_1 = lines; _i < lines_1.length; _i++) {
                                var line = lines_1[_i];
                                _loop_1(line);
                            }
                        });
                        return [2 /*return*/];
                }
            });
        });
    };
    FuncCli.prototype.stop = function () {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this._funcProcess) {
                            throw "func process not started";
                        }
                        return [4 /*yield*/, killAndWait(this._funcProcess)];
                    case 1:
                        _a.sent();
                        this._funcProcess = undefined;
                        return [2 /*return*/];
                }
            });
        });
    };
    FuncCli.prototype.fetch = function (url, init) {
        if (!/^https?\:\/\//.test(url)) {
            url = "".concat(this.baseUrl, "/").concat(url.replace(/^\/+/, ""));
        }
        return (0, node_fetch_1.default)(url, init);
    };
    FuncCli.prototype.waitForInvocations = function (functionName, times) {
        var _this = this;
        if (times === void 0) { times = 1; }
        return new Promise(function (resolve, reject) {
            _this._invocationWaiters.push({
                functionName: functionName,
                times: times,
                resolve: resolve,
                reject: reject,
                results: [],
            });
        });
    };
    FuncCli.prototype.waitForInvocation = function (functionName) {
        return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
            var results;
            return (0, tslib_1.__generator)(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.waitForInvocations(functionName, 1)];
                    case 1:
                        results = _a.sent();
                        return [2 /*return*/, results[0]];
                }
            });
        });
    };
    return FuncCli;
}());
exports.FuncCli = FuncCli;
function spawnAndWait(command, args, waitPort, opts) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var child;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    child = spawn(command, args, opts);
                    return [4 /*yield*/, waitOn({
                            resources: [
                                "tcp:localhost:".concat(waitPort)
                            ],
                            timeout: 30000
                        })];
                case 1:
                    _a.sent();
                    return [2 /*return*/, child];
            }
        });
    });
}
function killAndWait(proc) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        var k;
        return (0, tslib_1.__generator)(this, function (_a) {
            switch (_a.label) {
                case 0:
                    k = require('tree-kill');
                    k(proc.pid, 'SIGKILL');
                    _a.label = 1;
                case 1:
                    if (!isRunning(proc.pid)) return [3 /*break*/, 3];
                    return [4 /*yield*/, setTimeoutPromise(1000)];
                case 2:
                    _a.sent();
                    return [3 /*break*/, 1];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function setTimeoutPromise(ms) {
    return (0, tslib_1.__awaiter)(this, void 0, void 0, function () {
        return (0, tslib_1.__generator)(this, function (_a) {
            return [2 /*return*/, new Promise(function (resolve, reject) {
                    setTimeout(function () {
                        resolve();
                    }, ms);
                })];
        });
    });
}
function isRunning(pid) {
    if (!pid) {
        return false;
    }
    try {
        process.kill(pid, 0);
        return true;
    }
    catch (e) {
        return e.code === 'EPERM';
    }
}
//# sourceMappingURL=index.js.map